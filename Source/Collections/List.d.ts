import { IComparator } from './IComparator';
import { IEquatable } from '../types';
import { IEqualityComparator } from './IEqualityComparator';
import { IEnumerable } from './IEnumerable';
import { IList } from './IList';
import { IQueryable } from './IQueryable';
import { SortOrder } from './SortOrder';
import { CombineFunction, IteratorFunction } from './types';
import { Collection } from './Collection';
import { Grouping } from './Grouping';
export declare class List<T> extends Collection<T> implements IList<T>, IQueryable<T>, IEquatable<IList<T>> {
    static range(start: number, end: number, step?: number): List<number>;
    static repeat<TValue>(value: TValue, times: number): List<TValue>;
    static generate<TValue>(generator: (index: number) => TValue, length: number): List<TValue>;
    clone(): List<T>;
    addRange(items: IEnumerable<T>): void;
    insert(item: T, index: number): void;
    insertRange(items: IEnumerable<T>, index: number): void;
    removeAt(index: number): void;
    removeBy(predicate: IteratorFunction<T, boolean>): void;
    removeAll(other: IEnumerable<T>, comparator?: IEqualityComparator<T>): void;
    indexOf(searchItem: T, startIndex?: number, count?: number, comparator?: IEqualityComparator<T>): number;
    forEach(iterator: IteratorFunction<T, boolean | void>): void;
    aggregate<TAggregate>(iterator: (lastSeed: TAggregate, item: T, index: number, list: IEnumerable<T>) => TAggregate, initialSeed?: TAggregate): TAggregate;
    select<TResult>(selector: IteratorFunction<T, TResult>): List<TResult>;
    selectMany<TInnerItem, TResult>(collectionSelector: IteratorFunction<T, IEnumerable<TInnerItem>>, resultSelector: CombineFunction<T, TInnerItem, TResult>): List<TResult>;
    where(predicate: IteratorFunction<T, boolean>): List<T>;
    all(predicate: IteratorFunction<T, boolean>): boolean;
    any(predicate: IteratorFunction<T, boolean>): boolean;
    average(selector: IteratorFunction<T, number>): number;
    count(predicate: IteratorFunction<T, boolean>): number;
    first(predicate: IteratorFunction<T, boolean>, defaultValue?: T): T;
    firstOrDefault(defaultValue: T): T;
    last(predicate: IteratorFunction<T, boolean>, defaultValue?: T): T;
    lastOrDefault(defaultValue: T): T;
    distinct(comparator?: IEqualityComparator<T>): List<T>;
    groupBy<TKey>(keySelector: IteratorFunction<T, TKey>, keyComparator?: IEqualityComparator<TKey>): List<Grouping<TKey, T>>;
    except(otherList: IEnumerable<T>, comparator?: IEqualityComparator<T>): List<T>;
    intersect(otherList: IEnumerable<T>, comparator?: IEqualityComparator<T>): List<T>;
    join<TOuter, TKey, TResult>(outerList: IEnumerable<TOuter>, outerKeySelector: IteratorFunction<TOuter, TKey>, innerKeySelector: IteratorFunction<T, TKey>, resultSelector: CombineFunction<T, TOuter, TResult>, keyComparator?: IEqualityComparator<TKey>): List<TResult>;
    min(selector: IteratorFunction<T, number>): number;
    max(selector: IteratorFunction<T, number>): number;
    orderBy<TKey>(keySelector: (item: T) => TKey, comparator: IComparator<TKey>, sortOrder?: SortOrder): List<T>;
    reverse(): List<T>;
    equals(otherList: IEnumerable<T>, comparator?: IEqualityComparator<T>): boolean;
    skip(offset: number): List<T>;
    skipWhile(predicate: IteratorFunction<T, boolean>): List<T>;
    take(length: number): List<T>;
    takeWhile(predicate: IteratorFunction<T, boolean>): List<T>;
    slice(offset: number, length: number): List<T>;
    concat(otherList: IEnumerable<T>): List<T>;
    union(otherList: IEnumerable<T>, comparator?: IEqualityComparator<T>): List<T>;
    zip<TOther, TResult>(otherList: IEnumerable<TOther>, resultSelector: CombineFunction<T, TOther, TResult>): List<TResult>;
    toCollection(): Collection<T>;
}
